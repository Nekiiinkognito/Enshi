// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: comments_queries.sql

package db_repo

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createComment = `-- name: CreateComment :one
INSERT INTO public."comments"
(comment_id, post_id, user_id, "content", created_at)
VALUES($1, $2, $3, $4, CURRENT_TIMESTAMP)
RETURNING comment_id, post_id, user_id, content, created_at
`

type CreateCommentParams struct {
	CommentID int64       `json:"comment_id"`
	PostID    pgtype.Int8 `json:"post_id"`
	UserID    pgtype.Int8 `json:"user_id"`
	Content   pgtype.Text `json:"content"`
}

func (q *Queries) CreateComment(ctx context.Context, arg CreateCommentParams) (Comment, error) {
	row := q.db.QueryRow(ctx, createComment,
		arg.CommentID,
		arg.PostID,
		arg.UserID,
		arg.Content,
	)
	var i Comment
	err := row.Scan(
		&i.CommentID,
		&i.PostID,
		&i.UserID,
		&i.Content,
		&i.CreatedAt,
	)
	return i, err
}

const deleteComment = `-- name: DeleteComment :exec
DELETE FROM public."comments"
WHERE comment_id = $1
`

func (q *Queries) DeleteComment(ctx context.Context, commentID int64) error {
	_, err := q.db.Exec(ctx, deleteComment, commentID)
	return err
}

const getCommentByUserId = `-- name: GetCommentByUserId :one
SELECT comment_id, post_id, user_id, "content", created_at
FROM public."comments"
where public."comments".user_id = $1 and public."comments".post_id = $2
`

type GetCommentByUserIdParams struct {
	UserID pgtype.Int8 `json:"user_id"`
	PostID pgtype.Int8 `json:"post_id"`
}

func (q *Queries) GetCommentByUserId(ctx context.Context, arg GetCommentByUserIdParams) (Comment, error) {
	row := q.db.QueryRow(ctx, getCommentByUserId, arg.UserID, arg.PostID)
	var i Comment
	err := row.Scan(
		&i.CommentID,
		&i.PostID,
		&i.UserID,
		&i.Content,
		&i.CreatedAt,
	)
	return i, err
}

const getCommentsForPostAsc = `-- name: GetCommentsForPostAsc :many
SELECT comment_id, post_id, user_id, "content", created_at
FROM public."comments"
where public."comments".post_id = $1
order by created_at ASC
LIMIT 10 offset ($2 * 10)
`

type GetCommentsForPostAscParams struct {
	PostID  pgtype.Int8 `json:"post_id"`
	Column2 interface{} `json:"column_2"`
}

func (q *Queries) GetCommentsForPostAsc(ctx context.Context, arg GetCommentsForPostAscParams) ([]Comment, error) {
	rows, err := q.db.Query(ctx, getCommentsForPostAsc, arg.PostID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Comment
	for rows.Next() {
		var i Comment
		if err := rows.Scan(
			&i.CommentID,
			&i.PostID,
			&i.UserID,
			&i.Content,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommentsForPostDesc = `-- name: GetCommentsForPostDesc :many
SELECT comment_id, post_id, user_id, "content", created_at
FROM public."comments"
where public."comments".post_id = $1
order by created_at DESC
LIMIT 10 offset ($2 * 10)
`

type GetCommentsForPostDescParams struct {
	PostID  pgtype.Int8 `json:"post_id"`
	Column2 interface{} `json:"column_2"`
}

func (q *Queries) GetCommentsForPostDesc(ctx context.Context, arg GetCommentsForPostDescParams) ([]Comment, error) {
	rows, err := q.db.Query(ctx, getCommentsForPostDesc, arg.PostID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Comment
	for rows.Next() {
		var i Comment
		if err := rows.Scan(
			&i.CommentID,
			&i.PostID,
			&i.UserID,
			&i.Content,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCommentByCommentId = `-- name: UpdateCommentByCommentId :one
UPDATE public."comments"
SET "content"=$2
WHERE comment_id=$1
RETURNING comment_id, post_id, user_id, content, created_at
`

type UpdateCommentByCommentIdParams struct {
	CommentID int64       `json:"comment_id"`
	Content   pgtype.Text `json:"content"`
}

func (q *Queries) UpdateCommentByCommentId(ctx context.Context, arg UpdateCommentByCommentIdParams) (Comment, error) {
	row := q.db.QueryRow(ctx, updateCommentByCommentId, arg.CommentID, arg.Content)
	var i Comment
	err := row.Scan(
		&i.CommentID,
		&i.PostID,
		&i.UserID,
		&i.Content,
		&i.CreatedAt,
	)
	return i, err
}
